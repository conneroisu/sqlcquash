package cmd

import (
	"bytes"
	"io"
	"io/fs"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
	"golang.org/x/sync/errgroup"
	"gopkg.in/yaml.v3"
)

const header = `-- Code generated by sqlcquash. DO NOT EDIT.
-- versions: 
--	sqlcquash: v0.0.2

`

// combineCmd represents the combine command
var combineCmd = &cobra.Command{
	Use:   "combine",
	Short: "Combines defined schemas, queries and seeds into single output files as defined in the config file. (`sqlcquash.yaml`)",
	Long: `
Combines defined schemas, queries and seeds into single output files as defined in the config file ("sqlcquash.yaml").
	`,
	Example: `
sqlcquash combine
	`,
	RunE: func(cmd *cobra.Command, _ []string) error {
		configPath, err := FindConfigFile()
		if err != nil {
			return err
		}
		configCnt, err := readFile(configPath)
		if err != nil {
			return err
		}
		config := Config{}
		err = yaml.Unmarshal([]byte(configCnt), &config)
		if err != nil {
			return err
		}
		dir, err := FindConfigDir(configPath)
		if err != nil {
			return err
		}
		err = os.Chdir(dir)
		if err != nil {
			return err
		}
		for _, inst := range config.Dbs {
			err = handleInstance(cmd, inst)
			if err != nil {
				return err
			}
		}
		return nil
	},
}

func handleInstance(
	cmd *cobra.Command,
	inst DbConfig,
) error {
	eg := errgroup.Group{}
	eg.SetLimit(3)
	if inst.MaxGoroutines > 0 {
		eg.SetLimit(inst.MaxGoroutines)
	}
	eg.Go(func() error {
		schemas, err := catFiles(inst.SchemasPath)
		if err != nil {
			return err
		}
		schemaFile, err := os.Create(inst.OutputSchema)
		if err != nil {
			return err
		}
		defer schemaFile.Close()
		_, err = schemaFile.WriteString(
			header + "\n" +
				strings.Join(schemas, "\n"))
		if err != nil {
			return err
		}
		return nil
	})
	eg.Go(func() error {
		queries, err := catFiles(inst.QueriesPath)
		if err != nil {
			return err
		}
		queryFile, err := os.Create(inst.OutputQueries)
		if err != nil {
			return err
		}
		defer queryFile.Close()
		_, err = queryFile.WriteString(
			header + "\n" +
				strings.Join(queries, "\n"))
		if err != nil {
			return err
		}
		return nil
	})
	eg.Go(func() error {
		seeds, err := catFiles(inst.SeedsPath)
		if err != nil {
			return err
		}
		seedFile, err := os.Create(inst.OutputSeeds)
		if err != nil {
			return err
		}
		defer seedFile.Close()

		_, err = seedFile.WriteString(
			header + "\n" +
				strings.Join(seeds, "\n"))
		if err != nil {
			return err
		}
		return nil
	})
	err := eg.Wait()
	if err != nil {
		return err
	}
	if inst.Fmt == "" {
		cmd.Printf("Skipping Formatting as no formatter was configured\n")
		return nil
	}
	cmd.Printf("Running formatter: %s\n", inst.Fmt)
	// pipe each file that contains the string "queries" to the formatter
	// and write the output to the file
	err = filepath.WalkDir(".", walkDirFn(&inst))
	if err != nil {
		return err
	}
	return nil
}

func walkDirFn(
	inst *DbConfig,
) func(path string, d fs.DirEntry, err error) error {
	return func(path string, _ fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		ext := filepath.Ext(path)
		if ext != ".sql" {
			slog.Debug("Skipping file", "path", path)
			return nil
		}

		if strings.Contains(path, inst.FmtContains) {
			var b bytes.Buffer
			split := strings.Split(inst.Fmt, " ")
			cmd := exec.Command(split[0], split[1:]...)
			cmd.Stdin, err = os.Open(path)
			if err != nil {
				return err
			}
			cmd.Stdout = &b
			cmd.Stderr = os.Stderr
			err := cmd.Run()
			if err != nil {
				return err
			}

			f, err := os.Create(path)
			if err != nil {
				return err
			}
			defer f.Close()
			_, err = f.WriteString(b.String())
			if err != nil {
				return err
			}

			return nil
		}
		return nil
	}
}

func catFiles(path string) ([]string, error) {
	files, err := filepath.Glob(path)
	if err != nil {
		return nil, err
	}
	var content []string
	for _, file := range files {
		cnt, err := readFile(file)
		if err != nil {
			return nil, err
		}
		content = append(content, cnt)
	}
	return content, nil
}

func readFile(path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer file.Close()
	content, err := io.ReadAll(file)
	if err != nil {
		return "", err
	}
	return string(content), nil
}
